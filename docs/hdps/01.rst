######
HDP 01
######

Naive, straight-forward, minimal approach.

===
API
===

----------------
Hook Declaration
----------------

Declare a hook called ``on_activated`` for class ``Profile`` and trigger its handlers from
method ``activate()``:

.. code-block:: python

    class Profile(Hookable):

        on_activated = Hook()

        def activate():
            self.on_activated.trigger()

Discussion
""""""""""

* Must inherit from some parent class ``Hookable`` (or use a class decorator which essentially does
  the same thing or replaces the class altogether) because later we'll need
  metaclass-level processing of the hook-able class before it is created.

-------------------------------
Class Hook Handler Registration
-------------------------------

Register two handlers for the ``on_activated`` hook inside ``Profile`` class:

.. code-block:: python

    class Profile(Hookable):

        on_activated = Hook()

        @on_activated
        def log_activation(self):
            print(f"Activating {self}")

        @on_activated
        def validate_activation(self):
            print(f"Validating activation of {self}")

        def activate():
            self.on_activated.trigger()


--------------------------------------------
Class Hook Handler Registration in Sub-Class
--------------------------------------------

Create class ``CustomProfile`` which inherits from ``Profile``. This class should register
a handler method called ``log_activation`` which must not affect
method of the same name registered in ``Profile`` class body as ``Profile.on_activated`` handler:

.. code-block:: python

    class CustomProfile(Profile):

        @Profile.on_activated
        def log_activation(self):
            print(f"Activating CUSTOM {self}")


Discussion
""""""""""

* Ugliness: ``@Profile.on_activated`` suggests we are modifying ``Profile`` class, but we are not.
* Implementation is complicated by the fact that inside ``CustomProfile`` class body, ``Profile.on_activated``
  is context-specific. In another class ``AnotherProfile`` it would mean a different thing. This means that
  this method should return temporary objects which are then handled by the metaclass of ``Profile``.


-----------------------------
Hook Declaration in Sub-Class
-----------------------------

Add a hook specific to the derived ``CustomProfile`` class -- ``on_customisation`` and register a
single handler for it:

.. code-block:: python

    class CustomProfile(Profile):

        on_customisation = Hook()

        @Profile.on_activated
        def log_activation(self):
            print(f"Activating CUSTOM {self}")

        @on_customisation
        def log_customisation(self):
            print(f"Customising {self}")

Discussion
""""""""""

* Ugliness: ``@Profile.on_activated`` and ``@on_customisations`` visually seem very different, unrelated to each other,
  but logically are quite related.

----------------------------------
Instance Hook Handler Registration
----------------------------------

Given ``p``, an instance of ``Profile``, how do I register a handler for ``on_activated`` which will be called only
when this particular instance is being activated?

.. code-block:: python

    master = Profile()

    @master.on_activated
    def on_master_profile_activated(profile):
        print(f"Activating master profile {profile}")

Discussion
""""""""""

* So, ``master.on_activated`` registers a handler, and ``master.on_activated.trigger`` triggers the hook?


-----------------------
Hook Handler Inspection
-----------------------

Handler inspection. Print a list of all registered handlers for a given hook with respect to the class, or a concrete
instance:

.. code-block:: python

    class Profile(Hookable):
        # .. code skipped ..
        pass

    class CustomProfile(Profile):
        # .. code skipped ..
        pass

    # List on_activated handlers associated with all Profile instances
    print(Profile.on_activated.handlers)

    # List on_activated handlers associated with all CustomProfile instances
    print(CustomProfile.on_activated.handlers)

    p = Profile()
    # List on_activated handlers associated with p
    print(p.on_activated.handlers)

    c = CustomProfile()
    # List on_activated handlers associated with c
    print(c.on_activated.handlers)


=========
Questions
=========

* Where are the registered class hook handlers stored?

* Where are the registered instance hook handlers stored?

* All hook handlers are instance methods. How is the first argument of these methods, ``self``, reliably populated
  from wherever the hook is triggered?

* What happens when user creates a new class ``CustomProfile`` which inherits from class ``Profile``
  and in the new class declares method with the same name as a hook declared in its parent class -- ``on_activated``?

* What is returned by ``Profile.on_activated``?

* What is returned by ``CustomProfile.on_activated``?

* What happens when ``Profile.on_activated()`` is called from outside ``Profile`` body?

* What happens when ``CustomProfile.on_activated()`` is called from outside ``CustomProfile`` body?

* What happens when ``Profile().on_activated()`` is called?

* What happens when ``CustomProfile().on_activated()`` is called?

* What happens to all of the above when class ``CombinedProfile`` inherits from
  ``FirstProfile`` and ``SecondProfile`` both of which inherit from ``Profile``?

* How to list all hooks available for a given class?
