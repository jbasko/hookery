######
HDP 02
######

==========
Main Ideas
==========

* Declare a class that serves as hook specification -- each its method representing a hook.

===========
Main Issues
===========

* Can ``Profile.Hooks`` be a class and a descriptor at the same time? Yes, should be replaced during
  ``Hookable`` sub-class construction.

===
API
===

----------------
Hook Declaration
----------------

Declare a hook called ``on_activated`` for class ``Profile`` and trigger its handlers from
method ``activate()``:

.. code-block:: python

    class Profile(Hookable):

        class Hooks(HookSpec):
            def on_activated(self):
                pass

        def activate():
            self.Hooks.on_activated.trigger()


Discussion
""""""""""

* ``Hooks`` class must inherit from some library class because we need ``Hooks.on_activated`` to be prepared
  before it is used to register handlers inside ``Profile`` body (see below).
* ``self.hooks`` was considered, but if ``Hookable`` declares ``hooks`` then users of an IDE could be confused by both
  ``Hooks`` and ``hooks`` being suggested for auto-complete.
* Actually, ``self.hooks.on_activated`` wouldn't be auto-completed because the IDE wouldn't know that ``self.hooks``
  is an instance of ``self.Hooks``.

-------------------------------
Class Hook Handler Registration
-------------------------------

Register two handlers for the ``on_activated`` hook inside ``Profile`` class:

.. code-block:: python

    class Profile(Hookable):

        class Hooks(HookSpec):
            def on_activated(self):
                pass

        @Hooks.on_activated
        def log_activation(self):
            print(f"Activating {self}")

        @Hooks.on_activated
        def validate_activation(self):
            print(f"Validating activation of {self}")

        def activate():
            self.Hooks.on_activated.trigger()


--------------------------------------------
Class Hook Handler Registration in Sub-Class
--------------------------------------------

Create class ``CustomProfile`` which inherits from ``Profile``. This class should register
a handler method called ``log_activation`` which must not affect
method of the same name registered in ``Profile`` class body as ``Profile.on_activated`` handler:

.. code-block:: python

    class CustomProfile(Profile):

        class Hooks(Profile.Hooks):
            pass

        @Hooks.on_activated
        def log_activation(self):
            print(f"Activating CUSTOM {self}")

but also this should work (see discussion below):

.. code-block:: python

    class CustomProfile(Profile):

        @Profile.Hooks.on_activated
        def log_activation(self):
            print(f"Activating CUSTOM {self}")


Discussion
""""""""""

* If ``CustomProfile`` declares no hooks of its own, it may look like a lot of boilerplate, but it is clear.
  The alternative is ``@Profile.Hooks.on_activated``. That means it needs to not register the handler,
  but instead return some temporary object that is then handled by ``Profile``'s metaclass.


-----------------------------
Hook Declaration in Sub-Class
-----------------------------

Add a hook specific to the derived ``CustomProfile`` class -- ``on_customisation`` and register a
single handler for it:

.. code-block:: python

    class CustomProfile(Profile):

        class Hooks(Profile.Hooks):
            def on_customisation(self):
                pass

        @Hooks.on_activated
        def log_activation(self):
            print(f"Activating CUSTOM {self}")

        @Hooks.on_customisation
        def log_customisation(self):
            print(f"Customising {self}")

Discussion
""""""""""

* If ``CustomProfile`` were to inherit from multiple classes, so would ``CustomProfile.Hooks``.

----------------------------------
Instance Hook Handler Registration
----------------------------------

Given ``p``, an instance of ``Profile``, how do I register a handler for ``on_activated`` which will be called only
when this particular instance is being activated?

.. code-block:: python

    master = Profile()

    @master.Hooks.on_activated
    def on_master_profile_activated(profile):
        print(f"Activating master profile {profile}")


Discussion
""""""""""

* ``master.Hooks`` must be bound to the instance, this means ``master.Hooks`` is not the same as ``Profile.Hooks``.
* Using ``Profile.Hooks.on_activated()`` decorator is not a good idea because
  that would require user to know what type ``master`` is of.


-----------------------
Hook Handler Inspection
-----------------------

Handler inspection. Print a list of all registered handlers for a given hook with respect to the class, or a concrete
instance:

.. code-block:: python

    # List on_activated handlers associated with all Profile instances
    print(Profile.Hooks.on_activated.handlers)

    # List on_activated handlers associated with all CustomProfile instances
    print(CustomProfile.Hooks.on_activated.handlers)

    p = Profile()
    # List on_activated handlers associated with p
    print(p.Hooks.on_activated.handlers)

    c = CustomProfile()
    # List on_activated handlers associated with c
    print(c.Hooks.on_activated.handlers)


=========
Questions
=========

* Where are the registered class hook handlers stored?

* Where are the registered instance hook handlers stored?

* All hook handlers are instance methods. How is the first argument of these methods, ``self``, reliably populated
  from wherever the hook is triggered?

* What happens when user creates a new class ``CustomProfile`` which inherits from class ``Profile``
  and in the new class declares method with the same name as a hook declared in its parent class -- ``on_activated``?

* What is returned by ``Profile.on_activated``?

* What is returned by ``CustomProfile.on_activated``?

* What happens when ``Profile.on_activated()`` is called from outside ``Profile`` body?

* What happens when ``CustomProfile.on_activated()`` is called from outside ``CustomProfile`` body?

* What happens when ``Profile().on_activated()`` is called?

* What happens when ``CustomProfile().on_activated()`` is called?

* What happens to all of the above when class ``CombinedProfile`` inherits from
  ``FirstProfile`` and ``SecondProfile`` both of which inherit from ``Profile``?

* How to list all hooks available for a given class?
