######
HDP 03
######

==========
Main Ideas
==========

* Explore the global functions approach.

===========
Main Issues
===========

* It is actually quite clean and straight-forward.

===
API
===

----------------
Hook Declaration
----------------

Declare a hook called ``on_activated`` for class ``Profile`` and trigger its handlers from
method ``activate()``:

.. code-block:: python

    class Profile:

        on_activated = Hook()

        def activate(self):
            hooks.trigger(self.on_activated, *args, **kwargs)


Discussion
""""""""""

* ``Profile.on_activated`` is an unbound hook, whereas ``self.on_activated`` is bound to the instance of ``Profile``
  therefore ``hooks.trigger`` should be able to work out the subject of the hook -- ``self``.

-------------------------------
Class Hook Handler Registration
-------------------------------

Register two handlers for the ``on_activated`` hook inside ``Profile`` class:

.. code-block:: python

    class Profile:

        on_activated = Hook()

        @on_activated
        def log_activation(self):
            print(f"Activating {self}")

        @on_activated
        def validate_activation(self):
            print(f"Validating {self}")

        def activate(self):
            hooks.trigger(self.on_activated, *args, **kwargs)

Discussion
""""""""""

* Discuss implications of the design proposed above.


--------------------------------------------
Class Hook Handler Registration in Sub-Class
--------------------------------------------

Create class ``CustomProfile`` which inherits from ``Profile``. This class should register
a handler method ``log_activation`` which must not affect
method of the same name registered in ``Profile`` class body as ``Profile.on_activated`` handler:

.. code-block:: python

    class CustomProfile(Profile):

        @Profile.on_activated
        def log_activation(self):
            print(f"Activating CUSTOM {self}")


Discussion
""""""""""

* The attributes backing ``Profile.on_activated`` and ``CustomProfile.on_activated`` should be completely separate.
  The canonical descriptor ``__get__`` implementation would the same for attribute for all descendants of ``Profile``,
  but it is no good for us because we need to distinguish between classes for which the handlers are registered.


-----------------------------
Hook Declaration in Sub-Class
-----------------------------

Add a hook specific to the derived ``CustomProfile`` class -- ``on_customisation`` and register a
single handler for it:

.. code-block:: python

    class CustomProfile(Profile):

        on_customisation = Hook()

        @Profile.on_activated
        def log_activation(self):
            print(f"Activating CUSTOM {self}")

        @on_customisation
        def log_customisation(self):
            print(f"Customising {self}")


Discussion
""""""""""

* Discuss implications of the design proposed above.

----------------------------------
Instance Hook Handler Registration
----------------------------------

Given ``p``, an instance of ``Profile``, how do I register a handler for ``on_activated`` which will be called only
when this particular instance is being activated?

.. code-block:: python

    master = Profile()

    @master.on_activation
    def on_master_profile_activated(profile):
        print(f"Activating master profile {profile}")


Discussion
""""""""""

* Discuss implications of the design proposed above.

-----------------------
Hook Handler Inspection
-----------------------

Handler inspection. Print a list of all registered handlers for a given hook with respect to the class, or a concrete
instance:

.. code-block:: python

    class Profile:
        # .. code skipped ..
        pass

    class CustomProfile(Profile):
        # .. code skipped ..
        pass

    # List on_activated handlers associated with all Profile instances
    hooks.get_handlers(Profile.on_activated)

    # List on_activated handlers associated with all CustomProfile instances
    hooks.get_handlers(CustomProfile.on_activated)

    p = Profile()
    # List on_activated handlers associated with p
    hooks.get_handlers(p.on_activated)

    c = CustomProfile()
    # List on_activated handlers associated with c
    hooks.get_handlers(c.on_activated)


Discussion
""""""""""

* Discuss implications of the design proposed above.

=========
Questions
=========

* Where are the registered class hook handlers stored?

  **TODO** During the

  In the unbound ``Hook`` instance. As we are using a descriptor, it might not be initialised for some ancestor classes
  or the class itself.

* Where are the registered instance hook handlers stored?

* All hook handlers are instance methods. How is the first argument of these methods, ``self``, reliably populated
  from wherever the hook is triggered?

* What happens when user creates a new class ``CustomProfile`` which inherits from class ``Profile``
  and in the new class declares method with the same name as a hook declared in its parent class -- ``on_activated``?

* What is returned by ``Profile.on_activated``?

* What is returned by ``CustomProfile.on_activated``?

* What happens when ``Profile.on_activated()`` is called from outside ``Profile`` body?

* What happens when ``CustomProfile.on_activated()`` is called from outside ``CustomProfile`` body?

* What happens when ``Profile().on_activated()`` is called?

* What happens when ``CustomProfile().on_activated()`` is called?

* What happens to all of the above when class ``CombinedProfile`` inherits from
  ``FirstProfile`` and ``SecondProfile`` both of which inherit from ``Profile``?

* How to list all hooks available for a given class?

* How is it ensured that class associated handlers cannot be registered after the class has been created?

  We use ``__set_name__`` hook to mark ``Hook`` instance as finalised after which hook handlers
  cannot be registered with it. This means that the instance is used for handler registration only
  for the duration of class body parsing in which the hook was declared.

  In descendants of the class in which the hook is declared, the attribute with the hook's name resolves to
  a different object which is **bound to what????**
