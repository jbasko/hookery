######
HDP 03
######

==========
Main Ideas
==========

* Explore the global functions approach.

===========
Main Issues
===========

* It is actually quite clean and straight-forward.

=========
Changelog
=========

2018-08-21

Looks like we have to have a base class even with the global functions approach
because there is no way to distinguish between ``@Profile.on_activation``
decorators inside the body of ``class ProfileX(Profile)`` and ``class ProfileY(Profile)``.
For both we can just register the handler in ``Profile._subclass_handlers``
and that is it.

So, if we use the ``__init_subclass__`` hook (make sure that the user can still
have their own ``__init_subclass__`` implementation -- document how to integrate),
then we can:

.. code-block:: python

    class Hookable:

        @classmethod
        def __init_subclass__(cls, **kwargs):
            super().__init_subclass__(**kwargs)

            for base_cls in cls.__bases__:

                # For each hook
                # Get subclass handlers
                # Register them on this class's (cls) corresponding hook
                # as own handlers.

Or, we could enforce handler registration on the last base class that is subclass
of ``Hookable`` in the list of base classes?

No, each could have different hooks... Must go through all.

.. code-block:: python

    class D(A, B, C):

        @A.a
        def handle_a(self):
            pass

        @B.b
        def handle_b(self):
            pass

        @C.c
        def handle_c(self):
            pass

After the code above runs:

.. code-block:: python

    A._subclass_handlers == []  # cleared!
    D.a._own_handlers == [D.handle_a]
    B.b._own_handlers == [D.handle_b]

There is still a problem if someone does this:

**THIS MIGHT BE A GOOD TEST FOR OTHER ISSUES TOO**


.. code-block:: python

    class D(A):

        @A.a
        def handle_a(self):
            pass

        class E(A):
            @A.a
            def handle_a(self):
                pass

        @A.a
        def handle_a(self):
            pass


Ok, this is unacceptably dirty.

...

Have to mark the handlers as temporary and then update them when processing
by ``__init_subclass__``?

===
API
===

----------------
Hook Declaration
----------------

Declare a hook called ``on_activated`` for class ``Profile`` and trigger its handlers from
method ``activate()``:

.. code-block:: python

    class Profile:

        on_activated = Hook()

        def activate(self):
            hooks.trigger(self.on_activated, *args, **kwargs)


Discussion
""""""""""

* ``Profile.on_activated`` is an unbound hook, whereas ``self.on_activated`` is bound to the instance of ``Profile``
  therefore ``hooks.trigger`` should be able to work out the subject of the hook -- ``self``.

-------------------------------
Class Hook Handler Registration
-------------------------------

Register two handlers for the ``on_activated`` hook inside ``Profile`` class:

.. code-block:: python

    class Profile:

        on_activated = Hook()

        @on_activated
        def log_activation(self):
            print(f"Activating {self}")

        @on_activated
        def validate_activation(self):
            print(f"Validating {self}")

        def activate(self):
            hooks.trigger(self.on_activated, *args, **kwargs)

Discussion
""""""""""

* Discuss implications of the design proposed above.


--------------------------------------------
Class Hook Handler Registration in Sub-Class
--------------------------------------------

Create class ``CustomProfile`` which inherits from ``Profile``. This class should register
a handler method ``log_activation`` which must not affect
method of the same name registered in ``Profile`` class body as ``Profile.on_activated`` handler:

.. code-block:: python

    class CustomProfile(Profile):

        @Profile.on_activated
        def log_activation(self):
            print(f"Activating CUSTOM {self}")


Discussion
""""""""""

* The attributes backing ``Profile.on_activated`` and ``CustomProfile.on_activated`` should be completely separate.
  The canonical descriptor ``__get__`` implementation would return the same for attribute for all descendants
  of ``Profile``, but it is no good for us because we need to distinguish between classes for which the handlers
  are registered.
* Now, it is important to ensure that ``log_activation`` is registered as a handler only for ``CustomProfile`` and
  its sub-classes and not for other sub-classes of ``Profile``.

  How to do that? At the time when we register ``log_activation``,
  there is no class ``CustomProfile``. **We must store this handler separately and then determine at trigger time
  if it relates to the class or instance on which the hook is triggered.**

  Is it doable?


-----------------------------
Hook Declaration in Sub-Class
-----------------------------

Add a hook specific to the derived ``CustomProfile`` class -- ``on_customisation`` and register a
single handler for it:

.. code-block:: python

    class CustomProfile(Profile):

        on_customisation = Hook()

        @Profile.on_activated
        def log_activation(self):
            print(f"Activating CUSTOM {self}")

        @on_customisation
        def log_customisation(self):
            print(f"Customising {self}")


Discussion
""""""""""

* Discuss implications of the design proposed above.

----------------------------------
Instance Hook Handler Registration
----------------------------------

Given ``p``, an instance of ``Profile``, how do I register a handler for ``on_activated`` which will be called only
when this particular instance is being activated?

.. code-block:: python

    master = Profile()

    @master.on_activation
    def on_master_profile_activated(profile):
        print(f"Activating master profile {profile}")


Discussion
""""""""""

* Discuss implications of the design proposed above.

-----------------------
Hook Handler Inspection
-----------------------

Handler inspection. Print a list of all registered handlers for a given hook with respect to the class, or a concrete
instance:

.. code-block:: python

    class Profile:
        # .. code skipped ..
        pass

    class CustomProfile(Profile):
        # .. code skipped ..
        pass

    # List on_activated handlers associated with all Profile instances
    hooks.get_handlers(Profile.on_activated)

    # List on_activated handlers associated with all CustomProfile instances
    hooks.get_handlers(CustomProfile.on_activated)

    p = Profile()
    # List on_activated handlers associated with p
    hooks.get_handlers(p.on_activated)

    c = CustomProfile()
    # List on_activated handlers associated with c
    hooks.get_handlers(c.on_activated)


Discussion
""""""""""

* Discuss implications of the design proposed above.

=========
Questions
=========

* Where are the registered class hook handlers stored?

  **TODO** During the

  In the unbound ``Hook`` instance. As we are using a descriptor, it might not be initialised for some ancestor classes
  or the class itself.

* Where are the registered instance hook handlers stored?

* All hook handlers are instance methods. How is the first argument of these methods, ``self``, reliably populated
  from wherever the hook is triggered?

* What happens when user creates a new class ``CustomProfile`` which inherits from class ``Profile``
  and in the new class declares method with the same name as a hook declared in its parent class -- ``on_activated``?

* What is returned by ``Profile.on_activated``?

* What is returned by ``CustomProfile.on_activated``?

* What happens when ``Profile.on_activated()`` is called from outside ``Profile`` body?

* What happens when ``CustomProfile.on_activated()`` is called from outside ``CustomProfile`` body?

* What happens when ``Profile().on_activated()`` is called?

* What happens when ``CustomProfile().on_activated()`` is called?

* What happens to all of the above when class ``CombinedProfile`` inherits from
  ``FirstProfile`` and ``SecondProfile`` both of which inherit from ``Profile``?

* How to list all hooks available for a given class?

* How is it ensured that class associated handlers cannot be registered after the class has been created?

  We use ``__set_name__`` to mark ``Hook`` instance as finalised after which handlers
  cannot be registered with it. This means that the instance is used for handler registration only
  for the duration of class body parsing in which the hook was declared.

  In descendants of the class in which the hook is declared, the attribute with the hook's name resolves to
  a different object which is **bound to what????**
